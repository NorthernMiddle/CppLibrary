#pragma config(Sensor, dgtl1,  QuadEnc,  sensorQuadEncoder)
#pragma config(Motor,  port1,  MotorL,   tmotorVex393, openLoop, encoder, encoderPort, dgtl1, 1000)
#pragma config(Motor,  port10, MotorR,   tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-----------------------------------------------------------------------------*/
/*  Normally this function is part of a motor control library that accelerates */
/*  and decelerates motors at a pre-defined rate.  This is a stub so the       */
/*  example works.                                                             */
/*-----------------------------------------------------------------------------*/

void
SetMotor( short index, short speed )
{
    // bounds check index
    if((index < 0) || (index >= kNumbOfRealMotors))
        return;
    
    motor index ] = speed;    
}

/*-----------------------------------------------------------------------------*/
/*  Drive forwards until encoder count reached or timeout elapsed              */
/*  optionaly stop motors at end                                               */
/*-----------------------------------------------------------------------------*/

#define DRIVE_FORWARD_SPEED     127
#define DEFAULT_DRIVE_TIMEOUT  5000

void
DriveForwardsEncoder( int distance, bool stopdrive = true )
{
    long    cur_position;
    long    target_position;
    long    currentTime;

    // Get current drive position
    cur_position = nMotorEncoder MotorL ];

    // Where are we going
    target_position = cur_position + distance;

    // Start driving
    if(distance > 0)
        {
        SetMotor( MotorL, DRIVE_FORWARD_SPEED );
        SetMotor( MotorR, DRIVE_FORWARD_SPEED );
        }
    else
        {
        SetMotor( MotorL, -DRIVE_FORWARD_SPEED );
        SetMotor( MotorR, -DRIVE_FORWARD_SPEED );
        }
        
    // wait for end - break if timeout reached.
    for( currentTime = nSysTime; currentTime > (nSysTime - DEFAULT_DRIVE_TIMEOUT);)
        {
        cur_position = nMotorEncoder MotorL ];
        // forwards or backwards ?
        if( distance >= 0)
            {
            if( cur_position >= target_position )
                break;
            }
        else
            {
            if( cur_position <= target_position )
                break;
            }
        // Don't hog cpu
        wait1Msec(10);
        }

    // Stop driving
    if( stopdrive )
        {
        SetMotor( MotorL, 0 );
        SetMotor( MotorR, 0 );
        }
}


task main()
{
    // drive forwards 720 counts
    DriveForwardsEncoder( 720 );
    
    while(1)
        wait1Msec(25);
}
