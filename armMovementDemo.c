#pragma config(Sensor, in1,    ArmPot,         sensorPotentiometer)
#pragma config(Motor,  port1,  ArmMotor,     tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Arm movement demo code                                                     */
/*  James Pearman                                                              */
/*  Jan 9 2012                                                                 */
/*-----------------------------------------------------------------------------*/

#define     ARM_POSITION_TOLERANCE    25    // How close to target before stop is sent
#define     ARM_HIGH_LIMIT          2500    // Maximum upper potentiometer value
#define     ARM_LOW_LIMIT            600    // Maximum lower potentiometer value
#define     NO_BATTERY_THRESHOLD    3000    // Threshold for battery (in mV) for error
#define     MOVE_ARM_TIMEOUT        5000    // Maximum time (in mS) to move arm
#define     NO_MOVEMENT_THRESHOLD      5    // Threshold for detecting movement
#define     NO_MOVEMENT_TIME         250    // Timeout (in mS) when no movement is error
#define     ARM_LOOP_DELAY            25    // move arm loop delay

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Simple function to move motor to a given position based on potentiometer   */
/*  feedback.  Positive command values should give increasing potentiometer    */
/*  values                                                                     */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

int
MoveArm( int toPosition )
{
    long    currentTime;
    int     currentPosition;
    int     lastPosition;
    int     errorInPosition;
    int     movementError = 0;
    int     returnValue   = 0;

    // Get current position
    currentPosition = lastPosition = SensorValue ArmPot ];

    // check if we need to move
    if( abs( currentPosition - toPosition ) < ARM_POSITION_TOLERANCE )
        return(1);

    // move up or down ?
    if( currentPosition < toPosition )
        motor ArmMotor ] = 100;
    else
        motor ArmMotor ] = -100;

    // wait for end - 5 seconds maximum
    for( currentTime = nSysTime; currentTime > (nSysTime - MOVE_ARM_TIMEOUT);)
        {
        // delay at beginning of loop
        wait1Msec(ARM_LOOP_DELAY);

        // check power - abort if lost
        if( nImmediateBatteryLevel < NO_BATTERY_THRESHOLD )
            break;

        // Get current position
        currentPosition = SensorValue ArmPot ];

        // check absolute limits - should not happen
        if( ( (currentPosition > ARM_HIGH_LIMIT) && (motor ArmMotor ] > 0) ) || 
            ( (currentPosition < ARM_LOW_LIMIT ) && (motor ArmMotor ] < 0) )
            )
            break;

        // Check for movement
        if( abs(currentPosition - lastPosition) < NO_MOVEMENT_THRESHOLD )
            {
            // no movement for 250mS then abort
            if( ++movementError > (NO_MOVEMENT_TIME/ARM_LOOP_DELAY) )
                break;
            }
        else
            {
            // save current position
            lastPosition = currentPosition;
            // No error - arm is moving
            movementError = 0;
            }
            
        // calculate error and invert based on direction
        errorInPosition = (toPosition - currentPosition) * sgn(motor[ArmMotor]);

        // Check for arm in position
        if( errorInPosition < ARM_POSITION_TOLERANCE )
            {
            returnValue = 1; // success
            break;
            }
        }

    // Stop motor
    motor ArmMotor ] = 0;

    // return success(1) or failure(0)
    return(returnValue);
}
